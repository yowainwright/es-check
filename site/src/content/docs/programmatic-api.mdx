---
title: Programmatic API
description: Using ES Check programmatically in Node.js applications
---

# Programmatic API

While ES Check is primarily a command-line tool, it also exposes functions that allow you to use it programmatically within your Node.js applications. This is useful for integrating ES Check into build processes, testing frameworks, or custom tooling.

## Available Functions

ES Check exports two main functions for programmatic use:

- `runChecks(configs, loggerOrOptions)` - Run ES version checks on files
- `loadConfig(configPath)` - Load configuration from a file

## Basic Usage

The Node API now returns a result object instead of throwing errors, making it easier to handle programmatically:

```javascript
const { runChecks, loadConfig } = require("es-check");

async function checkES5Compatibility() {
  const configs = [
    {
      ecmaVersion: "es5",
      files: ["dist/**/*.js"],
      module: false,
      checkFeatures: true,
    },
  ];

  // Run without a logger (silent mode)
  const result = await runChecks(configs);

  if (result.success) {
    console.log("✅ All files are ES5 compatible!");
  } else {
    console.error(
      `❌ ES5 compatibility check failed with ${result.errors.length} errors`,
    );
    result.errors.forEach((error) => {
      console.error(`  - ${error.file}: ${error.err.message}`);
    });
    // Example output:
    // ES version mismatch detected
    // dist/legacy/app.js: Unsupported features used: const, let but your target is ES5.
    // dist/modern/polyfills.js: Unsupported features used: top-level-await but your target is ES2020.
    return { success: false, errors: result.errors };
  }
}
```

## Using with a Custom Logger

You can provide a custom logger for detailed output:

```javascript
const { runChecks } = require("es-check");

async function checkWithLogger() {
  const configs = [
    {
      ecmaVersion: "es6",
      files: ["src/**/*.js"],
      checkFeatures: true,
    },
  ];

  // Custom logger implementation
  const customLogger = {
    info: (msg) => console.log("[INFO]", msg),
    error: (msg) => console.error("[ERROR]", msg),
    warn: (msg) => console.warn("[WARN]", msg),
    debug: (msg) => console.debug("[DEBUG]", msg),
    isLevelEnabled: (level) => true,
  };

  // Pass logger in an options object
  const result = await runChecks(configs, { logger: customLogger });

  if (!result.success) {
    console.error("Check failed!");
    // Handle errors programmatically
    return { success: false, errors: result.errors };
  }
  return { success: true };
}
```

## Using the Built-in Logger

You can also use ES Check's built-in logger utility:

```javascript
const { runChecks } = require("es-check");
const { createLogger } = require("es-check/utils");

async function checkWithBuiltInLogger() {
  const configs = [
    {
      ecmaVersion: "es5",
      files: ["dist/**/*.js"],
    },
  ];

  // Create a logger with specific settings
  const logger = createLogger({
    verbose: true, // Show debug messages
    quiet: false, // Show all messages
    silent: false, // Output to console
    noColor: false, // Use colors in output
  });

  // Pass the logger in an options object
  const result = await runChecks(configs, { logger });

  if (!result.success) {
    // Handle errors programmatically
    return { success: false, errors: result.errors };
  }
  return { success: true };
}
```

## Configuration Options

The configuration object accepts the same options as the CLI:

```javascript
const config = {
  ecmaVersion: "es5", // ES version to check against
  files: ["dist/**/*.js"], // Files to check (array or string)
  module: false, // Use ES modules
  allowHashBang: false, // Allow hashbang comments
  checkFeatures: true, // Check for ES version specific features
  checkForPolyfills: false, // Consider polyfills when checking
  not: ["**/vendor/*.js"], // Files/folders to exclude
  looseGlobMatching: false, // Don't fail if no files found
  ignore: "ErrorCause,TopLevelAwait", // Features to ignore
  allowList: "const,let", // Features to allow in lower ES versions
  batchSize: 0, // Files to process concurrently (0 = unlimited)
};
```

## Loading Configuration from File

You can load configuration from `.escheckrc` or other config files:

```javascript
const { runChecks, loadConfig } = require("es-check");

async function checkWithConfigFile() {
  // Load config from .escheckrc or custom path
  const configs = await loadConfig("./.escheckrc");

  // Run checks without a logger (silent mode)
  const result = await runChecks(configs);

  if (!result.success) {
    console.error("ES Check failed!");
    // Handle errors programmatically
    return { success: false, errors: result.errors };
  }
  return { success: true };
}
```

## Integration Examples

### Build Script Integration

```javascript
const { runChecks } = require("es-check");

async function buildWithESCheck() {
  // Your build process
  await buildProject();

  // Check ES compatibility
  const configs = [
    {
      ecmaVersion: "es5",
      files: ["dist/**/*.js"],
      checkFeatures: true,
    },
  ];

  const result = await runChecks(configs);

  if (result.success) {
    console.log("Build successful - ES5 compatible");
  } else {
    console.error("Build failed - ES5 compatibility issues");
    console.error(`Found ${result.errors.length} incompatible files`);
    throw new Error("ES compatibility check failed");
  }
}
```

### Custom Testing

```javascript
const { runChecks } = require("es-check");

describe("ES Compatibility", () => {
  it("should be ES5 compatible", async () => {
    const configs = [
      {
        ecmaVersion: "es5",
        files: ["dist/**/*.js"],
        checkFeatures: true,
      },
    ];

    const result = await runChecks(configs);

    expect(result.success).toBe(true);
    expect(result.errors).toHaveLength(0);
  });
});
```

### Multiple ES Version Checks

```javascript
const { runChecks } = require("es-check");

async function checkMultipleTargets() {
  // Check different builds for different ES versions
  const configs = [
    {
      ecmaVersion: "es5",
      files: ["dist/legacy/**/*.js"],
      checkFeatures: true,
    },
    {
      ecmaVersion: "es2020",
      files: ["dist/modern/**/*.js"],
      checkFeatures: true,
    },
  ];

  const result = await runChecks(configs);

  if (result.success) {
    console.log("All builds match their target ES versions");
  } else {
    console.error("ES version mismatch detected");
    result.errors.forEach((error) => {
      console.error(`${error.file}: ${error.err.message}`);
    });
    // Example output:
    // ES version mismatch detected
    // dist/legacy/app.js: Unsupported features used: const, let but your target is ES5.
    // dist/modern/polyfills.js: Unsupported features used: top-level-await but your target is ES2020.
    return { success: false, errors: result.errors };
  }
}
```

### With Browserslist

```javascript
const { runChecks } = require("es-check");

async function checkBrowserCompatibility() {
  const configs = [
    {
      ecmaVersion: "checkBrowser",
      files: ["dist/**/*.js"],
      browserslistQuery: "last 2 versions, > 1%",
      checkFeatures: true,
    },
  ];

  const result = await runChecks(configs);

  if (!result.success) {
    console.error("Browser compatibility check failed");
    // Handle errors programmatically
    return { success: false, errors: result.errors };
  }
  // Output depends on logger configuration
  // Silent mode: no output
  // With logger: "ES-Check: Using ES11 based on browserslist configuration"
  return { success: true };
}
```

## Error Handling

The new Node API returns a result object with the following structure:

```javascript
{
  success: boolean,  // true if all checks passed
  errors: [          // array of error objects (empty if success is true)
    {
      file: string,  // path to the file that failed
      err: Error,    // the error object with details
      stack: string  // error stack trace
    }
  ]
}
```

Example error handling:

```javascript
const { runChecks } = require("es-check");

async function detailedErrorHandling() {
  const configs = [
    {
      ecmaVersion: "es5",
      files: ["dist/**/*.js"],
    },
  ];

  const result = await runChecks(configs);

  if (!result.success) {
    console.error(
      `ES Check found ${result.errors.length} incompatible files:\n`,
    );

    result.errors.forEach((error, index) => {
      console.error(`${index + 1}. File: ${error.file}`);
      console.error(`   Error: ${error.err.message}`);

      if (process.env.DEBUG) {
        console.error(`   Stack: ${error.stack}`);
      }
    });

    process.exit(1);
  }

  console.log("All files passed ES5 compatibility check!");
}
```

## CLI vs Node API Behavior

The Node API behaves differently from the CLI to be more suitable for programmatic use:

| Aspect     | CLI Behavior                       | Node API Behavior                           |
| ---------- | ---------------------------------- | ------------------------------------------- |
| On Error   | Calls `process.exit(1)`            | Returns `{ success: false, errors: [...] }` |
| On Success | Calls `process.exit(0)` or returns | Returns `{ success: true, errors: [] }`     |
| Logger     | Required (creates default)         | Optional                                    |
| Output     | Always logs to console             | Only logs if logger provided                |

## Backward Compatibility

For backward compatibility, if you pass a logger object directly (with `info`, `error`, etc. methods) as the second argument, it will behave like the CLI and call `process.exit()` on errors:

```javascript
const { runChecks } = require("es-check");
const { createLogger } = require("es-check/utils");

async function backwardCompatibleUsage() {
  const configs = [
    {
      ecmaVersion: "es5",
      files: ["dist/**/*.js"],
    },
  ];

  // Old style: passing logger directly (CLI behavior)
  const logger = createLogger();
  await runChecks(configs, logger); // Will call process.exit(1) on error
}
```

## Feature Detection

You can also use the `detectFeatures` function directly for more granular control:

```javascript
const detectFeatures = require("es-check/detectFeatures");

const code = `
  const arrow = () => console.log('arrow function');
  class MyClass {}
`;

const { foundFeatures, unsupportedFeatures } = detectFeatures(
  code,
  5, // ES5
  "script",
  new Set(), // ignored features
  { checkForPolyfills: false },
);

console.log("Found features:", foundFeatures);
console.log("Unsupported in ES5:", unsupportedFeatures);
```

## Notes

- The Node API is designed for programmatic use and returns structured results
- Silent mode (no logger) is the default for Node API usage
- All configuration options available in the CLI are supported
- The API is asynchronous and returns promises
- Multiple configurations can be checked in a single run
- The API will not call `process.exit()` unless a logger is passed directly (for backward compatibility)
